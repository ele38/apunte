<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.0ce842cb63b215ba8d61d4f188cdc42d3560f46238210188ce494f7fea26b58e7a43f81f53e114beec80e352f582637fa440d4da21c0508c971824a36b077806.css integrity="sha512-DOhCy2OyFbqNYdTxiM3ELTVg9GI4IQGIzklPf+omtY56Q/gfU+EUvuyA41L1gmN/pEDU2iHAUIyXGCSjawd4Bg==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Recurrencias Lineales - Programación Competitiva UChile</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/docs/extras/recurrencias_lineales/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Recurrencias Lineales"><meta name=twitter:description content="Introducción Las recurrencias lineales se ven como secuencias que cumplen una ecuación del tipo:
$$ a_k = \sum_{i\geq 1} c_i(k)a_{k-i} + f(k) $$
Es decir, secuencias donde cada valor depende de una función lineal de los valores anteriores, más alguna función de k.
Hay un sinfín de variedad de estas, la más clásica de todas siendo:
$$ f_k = f_{k-1} + f_{k-2} $$
La secuencia de Fibonacci. Otra clase de secuencias que podemos expresar usando esta terminología es: $$ T_n = 2T_{\lceil n/2 \rceil} + O(n) $$"><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Recurrencias Lineales"><meta property="og:description" content="Introducción Las recurrencias lineales se ven como secuencias que cumplen una ecuación del tipo:
$$ a_k = \sum_{i\geq 1} c_i(k)a_{k-i} + f(k) $$
Es decir, secuencias donde cada valor depende de una función lineal de los valores anteriores, más alguna función de k.
Hay un sinfín de variedad de estas, la más clásica de todas siendo:
$$ f_k = f_{k-1} + f_{k-2} $$
La secuencia de Fibonacci. Otra clase de secuencias que podemos expresar usando esta terminología es: $$ T_n = 2T_{\lceil n/2 \rceil} + O(n) $$"><meta property="og:type" content="article"><meta property="og:url" content="/docs/extras/recurrencias_lineales/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2022-12-04T02:48:45+00:00"><meta property="article:modified_time" content="2022-12-09T00:56:41-03:00"><meta property="og:site_name" content="Programación Competitiva UChile"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Docsextrasrecurrencias Lineales","item":"\/docsextrasrecurrencias_lineales\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/progcompuch/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/docs/prologo/intro>Apunte</a></li><li class=nav-item><a class=nav-link href=/recursos/prologo/intro>Recursos</a></li><li class=nav-item><a class=nav-link href=/cses>CSES</a></li><li class=nav-item><a class=nav-link href=/acerca>Acerca</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><main class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Prólogo</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/prologo/intro/>Prólogo</a></li></ul><h3>Intro a la Programación</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/intro/compilacion-editores/>Compilación y Editores de Texto</a></li><li><a class=docs-link href=/docs/intro/sintaxis/>Sintaxis, Variables, Tipos y Ciclos</a></li><li><a class=docs-link href=/docs/intro/funciones/>Funciones en C++</a></li><li><a class=docs-link href=/docs/intro/vectores/>Vectores</a></li><li><a class=docs-link href=/docs/intro/bits/>Operadores Bitwise</a></li></ul><h3>La STL</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/stl/strings/>Chars y Strings</a></li><li><a class=docs-link href=/docs/stl/pair-tuple/>Pair y Tuple</a></li><li><a class=docs-link href=/docs/stl/sort/>Sort</a></li><li><a class=docs-link href=/docs/stl/setmap/>Sets, Maps y Multisets</a></li><li><a class=docs-link href=/docs/stl/stackqueue/>Stack y Queue</a></li><li><a class=docs-link href=/docs/stl/priority_queue/>Priority Queue</a></li></ul><h3>Paradigmas de Resolución</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/paradigmas/busqueda-binaria/>Búsqueda Binaria</a></li><li><a class=docs-link href=/docs/paradigmas/programacion-dinamica/>Programación Dinámica</a></li></ul><h3>Estructuras de Datos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/ds/unionfind/>Union Find</a></li></ul><h3>Grafos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/grafos/introduccion/>Introducción</a></li><li><a class=docs-link href=/docs/grafos/busqueda/>Búsqueda en grafos (BFS y DFS)</a></li><li><a class=docs-link href=/docs/grafos/caminos_eulerianos/>Caminos y Ciclos Eulerianos</a></li><li><a class=docs-link href=/docs/grafos/mst/>Minimum Spanning Tree (MST)</a></li><li><a class=docs-link href=/docs/grafos/dijkstra/>Caminos más cortos</a></li></ul><h3>Extras</h3><ul class=list-unstyled><li><a class="docs-link active" href=/docs/extras/recurrencias_lineales/>Recurrencias Lineales</a></li><li><a class=docs-link href=/docs/extras/treaps/>Treaps</a></li></ul><h3>Anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/anexos/template/>Template</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><a href=#introducción>Introducción</a><ul><li></li></ul></li></ul><ul><li><a href=#caso-homogéneo><strong>Caso homogéneo</strong></a><ul><li><a href=#dp>DP</a></li><li><a href=#matrices>Matrices</a></li><li><a href=#el-método-kitamasa>El método Kitamasa</a></li></ul></li><li><a href=#caso-no-homogéneo><strong>Caso no Homogéneo</strong></a><ul><li><a href=#caso-fk--b-constante>Caso $f(k) = b$ constante</a></li><li><a href=#caso-fk--pk-polinomio>Caso $f(k) = p(k)$ polinomio</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Recurrencias Lineales</h1><p class=lead></p><h2 id=introducción>Introducción<a href=#introducción class=anchor aria-hidden=true>#</a></h2><p>Las recurrencias lineales se ven como secuencias que cumplen una ecuación del tipo:</p><p>$$
a_k = \sum_{i\geq 1} c_i(k)a_{k-i} + f(k)
$$</p><p>Es decir, secuencias donde cada valor depende de una función lineal de los valores anteriores, más alguna función de k.</p><p>Hay un sinfín de variedad de estas, la más clásica de todas siendo:</p><p>$$
f_k = f_{k-1} + f_{k-2}
$$</p><p>La secuencia de Fibonacci. Otra clase de secuencias que podemos expresar usando esta terminología es:
$$
T_n = 2T_{\lceil n/2 \rceil} + O(n)
$$</p><p>El tiempo que nos demoramos en ordenar un arreglo usando Quicksort. Dada la tremenda expresividad de este tipo de ecuaciones, se nos hace difícil poder resolverlas todas y nos vamos a restringir a una clase más acotada de ellas.</p><p>Vamos a decir que una recurrencia es a coeficientes constantes, si es que todos los $ c_i $ cumplen con ser una función constante, esto es, que $ c_i(k) = c_i $ para cada $ i $.</p><p>Y vamos a decir que tiene grado $ n $ si es que la parte lineal tiene exactamente $ n $ términos:</p><p>$$
a_k = \sum_{i=1}^{n} c_i a_{k-i} + f(k)
$$</p><p>Finalmente, diremos que es homogénea si es que $ f(k) = 0 $. Vamos a estudiar primero como resolver recurrencias lineales homogéneas, a coeficientes constantes y de grado finito primero. Luego, veremos algunas clases de recurrencias no homogéneas que también podemos resolver.</p><h4 id=nota-importante-sobre-módulos>Nota Importante sobre módulos<a href=#nota-importante-sobre-módulos class=anchor aria-hidden=true>#</a></h4><p>Los valores de estas secuencias crecen de forma extremadamente rápida (a velocidad exponencial!). Es por eso que los problemas que nos piden resolver este tipo de recurrencias por lo general las piden módulo un primo grande (nuestro amigo $10^9+7$). Es importante que cuando ustedes programen este tipo de soluciones se fijen en ese detalle, y no intenten programar lo aquí descrito de forma directa (probablemente un gran overflow y un wrong answer).</p><h1 id=recurrencias-lineales-a-coeficientes-constantes-y-de-grado-finito>Recurrencias lineales a coeficientes constantes y de grado finito</h1><p>Nos enfocaremos en el caso de las recurrencias más resolubles, es decir, aquellas a coeficientes constantes de grado $n$. Es importante destacar que para poder resolver la recurrencia, necesitamos los primeros $n$ terminos de la secuencia:$a_0, a_1 \dots a_{n-1}$. Esto pues no podemos utilizar la ecuación de recurrencia para determinar el valor de estos terminos, y sin ellos no hay suficiente información para determinar el resto.</p><h2 id=caso-homogéneo><strong>Caso homogéneo</strong><a href=#caso-homogéneo class=anchor aria-hidden=true>#</a></h2><p>Vamos a estudiar técnicas para resolver la recurrencia lineal &ldquo;más simple&rdquo; posible:</p><p>$$
a_k = \sum_{i=1}^{n} c_i a_{k-i}
$$</p><p>La forma más común de atacar este tipo de ecuaciones es a través de estudiar el polinomio característico de la recurrencia, definido como:</p><p>$$
c(\lambda) = \lambda^n - \sum_{i=1}^n c_i \lambda^{n-i}
$$</p><p>Se puede ver que si $ \lambda $ es raíz de este polinomio, entonces la secuencia $ a_k = \lambda^k $ cumple con la recurrencia, y
adicionalmente podemos recuperar todas las soluciones de la recurrencia si es que sabemos todas las raíces del polinomio. No
ahondaremos en este método pues:</p><ol><li>Requiere solucionar polinomios de potencialmente grado $>4$, que no podemos hacer de forma algebraica en todos los casos.</li><li>Aún cuando podemos obtener las raíces, no es fácil obtener la la solución a la recurrencia a partir de ellas, pues o bien
requiere usar números de punto flotante que no es estable númericamente, o requiere usar &ldquo;magia oscura algebraica&rdquo; que es mejor
aplicar mediante otros métodos.</li></ol><p>Veremos 3 métodos de resolver esta ecuación:</p><h3 id=dp>DP<a href=#dp class=anchor aria-hidden=true>#</a></h3><p>Es una aplicación directa de DP generar la solución de estas recurrencias. Usamos:</p><ul><li>$\text{DP}[k] = a_k \ \text{para } k &lt; n $</li><li>$\text{DP}[k] = \sum_{i=1}^n c_i \text{DP}[k-i] $</li></ul><p>Obtenemos una complejidad de $O(NK)$ en tiempo, y $O(K)$ en memoria para obtener la secuencia hasta un $K$ fijo. Esta es la solución más básica y menos optimizada, pero tambien la más fácil de programar. Igual es importante destacar que está es la solución más fácil de extender, pues también sirve para el caso de coeficientes no constantes y recurrencias no homogéneas.</p><details><summary>Código</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>
<span class=c1>// Trabajar con números de 64 bits 
</span><span class=c1></span>
<span class=k>const</span> <span class=n>ll</span> <span class=n>MOD</span> <span class=o>=</span> <span class=mf>1e9</span><span class=o>+</span><span class=mi>7</span><span class=p>;</span>

<span class=o>%</span> <span class=n>A</span> <span class=n>los</span> <span class=n>casos</span> <span class=n>base</span><span class=p>,</span> <span class=n>C</span> <span class=n>los</span> <span class=n>coeficientes</span>
<span class=n>ll</span> <span class=n>calcular_ak</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>c</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> 
  <span class=c1>// Necesitamos tantos casos base como el grado de la recurrencia
</span><span class=c1></span>
  <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
  <span class=k>if</span><span class=p>(</span><span class=n>K</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>)</span> <span class=k>return</span> <span class=n>a</span><span class=p>[</span><span class=n>K</span><span class=p>];</span>

  <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=n>DP</span><span class=p>(</span><span class=n>K</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=n>DP</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>

  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>N</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>K</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>DP</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>N</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>DP</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>DP</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>];</span>
      <span class=n>DP</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=n>DP</span><span class=p>[</span><span class=n>K</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></div></details><h3 id=matrices>Matrices<a href=#matrices class=anchor aria-hidden=true>#</a></h3><p>Podemos expresar la recurrencia de forma matricial:</p><p>$$
\begin{pmatrix}
c_1 & c_2 & \cdots & c_n\\<br>1 & 0 & \cdots & 0 \\<br>0 & 1 & \cdots & 0 \\<br>\vdots & \ddots & \ddots & \vdots \\<br>0 & \cdots & 1 & 0
\end{pmatrix}
\begin{pmatrix}
a_{k-1} \\<br>a_{k-2} \\<br>\vdots \\[1.5em]
a_{k-n}
\end{pmatrix} =
\begin{pmatrix}
a_{k} \\<br>a_{k-1} \\<br>\vdots \\[1.5em]
a_{k-(n-1)}
\end{pmatrix}
$$</p><p>Llamando $\mathbf{C}$ a esta matriz, y definiendo $\mathbf{a_k} = (a_{k+(n-1)} \dots a_{k+1}, a_{k})^t$, podemos escribir de forma más sucinta:</p><p>$$
\mathbf{C}\mathbf{a_{k-1}} = \mathbf{a_k}
$$</p><p>Que tiene una solución bastante simple para el $k$-ésimo termino:</p><p>$$
\mathbf{a_k} = \mathbf{C^{k}}\mathbf{a_{0}}
$$</p><p>Con lo que podemos rescatar el $k$-ésimo termino de la secuencia elevando la matriz a $k$, y obteniendo $a_k$ a partir de $\mathbf{a_k}$. ¿Cuanto tiempo nos toma calcular esta potencia de matriz? Multiplicar dos matrices de tamaño $N \times N$ nos toma tiempo $O(N^3)$, y utilizando exponenciación rápida podemos calcular la $k$-ésima potencia utilizando $O(\log(K))$ multiplicaciones. En total, utilizamos $O(N^3 \log(K))$ tiempo.</p><p>Esta solución nos será útil solo para alrededor de $N \leq 500$, pero lo importante es que nos permite acceder a valores mucho más grandes de $K$. Valores como $K = 10^{18}$ no son en absoluto un problema para esta técnica.</p><details><summary>Código</summary><p><strong>Código para multiplicar mátrices</strong></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>
<span class=k>const</span> <span class=n>ll</span> <span class=n>MOD</span> <span class=o>=</span> <span class=mf>1e9</span><span class=o>+</span><span class=mi>7</span><span class=p>;</span>

<span class=k>struct</span> <span class=nc>matrix</span> <span class=p>{</span>
  <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;&gt;</span> <span class=n>data</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>m</span><span class=p>;</span>

  <span class=n>matrix</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>)</span> <span class=o>:</span> <span class=n>n</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>m</span><span class=p>(</span><span class=n>m</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>data</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
  <span class=p>}</span>

  <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
  <span class=p>}</span>

  <span class=n>ll</span> <span class=nf>access</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>matrix</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>matrix</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>,</span> <span class=k>const</span> <span class=n>matrix</span> <span class=o>&amp;</span><span class=n>B</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>m</span> <span class=o>==</span> <span class=n>B</span><span class=p>.</span><span class=n>n</span><span class=p>);</span> <span class=c1>// Verificar que las dimensiones calcen
</span><span class=c1></span>  <span class=n>matrix</span> <span class=nf>C</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>,</span> <span class=n>B</span><span class=p>.</span><span class=n>m</span><span class=p>);</span>

  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>B</span><span class=p>.</span><span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span><span class=o>*</span><span class=n>B</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
        <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=n>C</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>matrix</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>,</span> <span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>m</span> <span class=o>==</span> <span class=n>x</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
  <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=n>y</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span><span class=o>*</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
      <span class=n>y</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=n>y</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><strong>Ahora, código para obtener la secuencia</strong></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>matrix</span> <span class=nf>exponenciacion_rapida</span><span class=p>(</span><span class=n>matrix</span> <span class=o>&amp;</span><span class=n>A</span><span class=p>,</span> <span class=n>ll</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>n</span> <span class=o>==</span> <span class=n>A</span><span class=p>.</span><span class=n>m</span><span class=p>);</span> <span class=c1>// Solo podemos elevar matrices cuadradas
</span><span class=c1></span>  <span class=n>matrix</span> <span class=n>ans</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>,</span> <span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>);</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=n>ans</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
  <span class=c1>// ans es ahora la matriz identidad, o A^0
</span><span class=c1></span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>bit</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>bit</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>bit</span> <span class=o>&lt;&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>((</span><span class=n>bit</span><span class=o>&amp;</span><span class=n>n</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>ans</span> <span class=o>=</span> <span class=n>A</span><span class=o>*</span><span class=n>ans</span><span class=p>;</span> <span class=c1>// Si el k-esimo bit está prendido, multiplicar por A^2^k
</span><span class=c1></span>    <span class=n>A</span> <span class=o>=</span> <span class=n>A</span><span class=o>*</span><span class=n>A</span><span class=p>;</span> <span class=c1>// Conseguir la siguiente potencia binaria de A
</span><span class=c1></span>  <span class=p>}</span>

  <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>ll</span> <span class=nf>calcular_ak</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=n>ll</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>c</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> 
  <span class=c1>// Necesitamos tantos casos base como el grado de la recurrencia
</span><span class=c1></span>  
  <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
  <span class=k>if</span><span class=p>(</span><span class=n>K</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>)</span> <span class=k>return</span> <span class=n>a</span><span class=p>[</span><span class=n>K</span><span class=p>];</span>

  <span class=n>matrix</span> <span class=n>C</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>N</span><span class=p>);</span>
  <span class=n>C</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>

  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

  <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
  <span class=n>reverse</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>x</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>

  <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=n>y</span> <span class=o>=</span> <span class=n>exponenciacion_rapida</span><span class=p>(</span><span class=n>C</span><span class=p>,</span> <span class=n>K</span><span class=p>)</span><span class=o>*</span><span class=n>x</span><span class=p>;</span>
  <span class=k>return</span> <span class=n>y</span><span class=p>.</span><span class=n>back</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></details><h3 id=el-método-kitamasa>El método Kitamasa<a href=#el-método-kitamasa class=anchor aria-hidden=true>#</a></h3><p>Los dos métodos anteriores nos permiten atacar recurrencias donde o bien ambos $n$ y $k$ son pequeños, o $n$ es extremadamente pequeño y $k$ puede ser tan grande como deseemos. Vamos a estudiar un último método que nos permitirá resolver recurrencias cuando $n$ es un poco más grande y no es posible aplicar el metodo matricial.</p><p>Una gracia del método matricial es que nos permite calcular $a_k$ usando solamente los primeros $n$ términos, es decir $a_k = \sum_{i=0}^{n-1} d_i(k) a_i$. Podemos intentar lograr esto aplicando la recurrencia repetidas veces. Por ejemplo, para la recurrencia $a_k = 2a_{k-1} + a_{k-2}$ vemos que:</p><p>$$
\begin{matrix}
a_5 & = & 2a_4 + a_3 \\<br>a_5 & = & 2(2a_3 + a_2) + a_3 & = & 5a_3 + 2a_2 \\<br>a_5 & = & 5(2a_2 + a_1) + 2a_2 & = & 12a_2 + 5a_1 \\<br>a_5 & = & 12(2a_1 + a_0) + 5a_1 & = & 29a_1 + 12a_0
\end{matrix}
$$</p><p>En este caso $d_1 = 29$ y $d_0 = 12$. Podemos repensar este método como ir restando $q(a_k - \sum_{i=1}^n c_i a_{k-i}) = 0$ en cada paso para anular el termino lider, algo así como:</p><p>$$
\begin{matrix}
a_5 & = & 2a_4 + a_3 & - & 2(a_4 - 2a_3 - a_2) & = & 5a_3 + 2a_2\\<br>a_5 & = & 5a_3 + 2a_2 & - & 5(a_3 - 2a_2 - a_1) & = & 12a_2 + 5a_1 \\<br>a_5 & = & 12a_2 + 5a_1 & - & 12(a_2 - 2a_1 - a_0) & = & 29a_1 + 12a_0 \\<br>\end{matrix}
$$</p><p>Si miramos un buen rato, este proceso puede recordarnos a otro algoritmo&mldr; ¡de hecho, este proceso es equivalente al proceso de división de polinomios!</p><p>Para formalizar esta relación con polinomios, utilizaremos un poco de magia algebraica. Definiremos una aplicación lineal sobre polinomios mediante $G(x^i) = a_i$. El problema de calcular $a_k$ se reduce, entonces, al problema de calcular $G(x^k)$. ¿Que utilidad tiene $G$? Notar que $G$ cumple una relación interesante con el polinomio característico de la recurrencia:</p><p>$$ \begin{align*}
c(x) &= x^n - \sum_{i=1}^n c_i x^{n-i} \\[1.2em]
G(c) &= a_n - \sum_{i=1}^n c_i a_{n-i} = 0
\end{align*}
$$</p><p>Aún más, dado que la recurrencia se cumple en todos los índices mayores que $n$, podemos afirmar que para $d>0$ se cumple:</p><p>$$
G(x^dc) = a_{n+d} - \sum_{i=1}^nc_ia_{(n+d)-i} = 0
$$</p><p>Y luego, por extensión, tenemos que para cualquier polinomio $p$:</p><p>$$\begin{align*}
p(x) &= \sum_{j=0}^{m} p_j x^j \\<br>G(pc) &= \sum_{j=0}^m p_jG(x^jc) = 0
\end{align*}$$</p><p>Aquí entra el gran truco: gracias al algoritmo de Euclides, sabemos que existen polinomios $q(x)$ y $r(x)$, de grado $k-n$ y $&lt;n$ respectivamente, tal que podemos escribir:</p><p>$$
x^k = q(x)c(x) + r(x)
$$</p><p>¡Y la gracia es que podemos aplicar $G$ a esta ecuación!</p><p>$$
G(x^k) = G(qc + r) = G(qc) + G(r) = G(r)
$$</p><p>Escrito de forma más formal, se cumple la ecuación:</p><p>$$
G(x^k) = G(x^k \text{ mod } c)
$$</p><p>Cabe destacar que como $x^k \text{ mod } c$ tiene grado $&lt;n$, para calcular $G(r)$ solamente necesitamos aquellos valores de $a_i$ con $i&lt;n$, y estos corresponden a los casos base de nuestra recurrencia. Entonces, el problema se reduce a calcular $x^k \text{ mod } c$. ¿Como podemos hacer esto de forma eficiente? Si aplicamos el algoritmo de Euclides de forma directa, el calculo tomaría alrededor de $k-n$ pasos donde en cada paso tenemos que restar un multiplo de $c$, es decir que en complejidad tomaría $O(N(K-N)) = O(NK)$ pasos. Esto no mejora en nada respecto al primer método.</p><p>La gracia es hacer este calculo de forma más inteligente. Aplicando el algoritmo de exponenciación rápida, podemos calcular $x^k \text{ mod } c$ a partir de $x \text{ mod } c, \ x^2 \text{ mod } c, \ x^4 \text{ mod } c \dots$. Necesitaremos $O(\log(K))$ de estos polinomios, y en cada paso tendremos que obtener el módulo $c$ de un polinomio de grado a lo más $2N$. Aplicando el algoritmo de Euclides de forma directa, esto nos toma en el peor caso tiempo $O(N(2N-N)) = O(N^2)$ pasos, ¡que nos lleva a un algoritmo final con complejidad $O(N^2 \log(K))$ pasos!</p><p>Para concluir, vamos a describir el algoritmo a grandes rasgos:</p><ol><li>Calcular los polinomios $r_d(x) = [x^{2^d} \text{ mod } c]$ para todos los $d \geq 1$ tales que $2^d \leq k$. Complejidad $O(N^2\log(K))$.</li><li>A partir de la descomposición binaria de $k = \sum b_d 2^d$, multiplicar los $r_d(x)$ y aplicar$\text{ mod } c$ para aquellos $d$ donde $b_d = 1$, para obtener $r(x) = [x^k \text{ mod } c]$. Complejidad $O(N^2\log(K))$</li><li>Calcular $G(r)$ para obtener $a_k$. Complejidad $O(N)$.</li></ol><p>Y utilizando todo esto obtenemos un algoritmo de complejidad $O(N^2\log(K))$ para calcular $a_k$. Como último detalle, este algoritmo puede mejorarse aún más a una complejidad de $O(N\log(N)\log(K))$ utilizando técnicas avanzadas de polinomios. Se pueden encontrar más detalles <a href=https://www.pc-arg.com/media/attachment/fft.pdf>aquí</a>.</p><details><summary>Código</summary><p><strong>Código para polinomios</strong></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>
<span class=k>const</span> <span class=n>ll</span> <span class=n>MOD</span> <span class=o>=</span> <span class=mf>1e9</span><span class=o>+</span><span class=mi>7</span><span class=p>;</span>

<span class=k>struct</span> <span class=nc>poly</span> <span class=p>{</span>
  <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=n>coef</span><span class=p>;</span> <span class=c1>// vector de coeficientes
</span><span class=c1></span>  <span class=kt>int</span> <span class=n>n</span><span class=p>;</span> <span class=c1>// El grado del polinomio
</span><span class=c1></span>
  <span class=n>poly</span><span class=p>()</span> <span class=o>:</span> <span class=n>n</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// Usaremos grado -1 para el polinomio &#34;vacío&#34;
</span><span class=c1></span>  <span class=n>poly</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;&amp;</span><span class=n>A</span><span class=p>)</span> <span class=o>:</span> <span class=n>coef</span><span class=p>(</span><span class=n>A</span><span class=p>),</span> <span class=n>n</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{}</span>
  <span class=n>poly</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=o>:</span> <span class=n>n</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>coef</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=n>ll</span> <span class=o>&amp;</span><span class=k>operator</span><span class=p>[](</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>coef</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
  <span class=p>}</span>

  <span class=n>ll</span> <span class=nf>access</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>coef</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
  <span class=p>}</span>

  <span class=c1>// Asegura que el coeficiente principal no es 0
</span><span class=c1></span>  <span class=kt>void</span> <span class=nf>fit</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>coef</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>coef</span><span class=p>.</span><span class=n>back</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>coef</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=n>n</span> <span class=o>=</span> <span class=n>coef</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=n>ll</span> <span class=nf>eval</span><span class=p>(</span><span class=n>ll</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ll</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>ans</span> <span class=o>+=</span> <span class=n>coef</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>*</span><span class=n>y</span><span class=p>;</span>
      <span class=n>ans</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
      <span class=n>y</span> <span class=o>=</span> <span class=n>y</span><span class=o>*</span><span class=n>x</span><span class=o>%</span><span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>};</span>

<span class=n>poly</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=k>const</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>poly</span> <span class=nf>c</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>n</span> <span class=o>+</span> <span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=p>);</span>

  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>a</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>a</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=o>*</span><span class=n>b</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
      <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=n>c</span><span class=p>.</span><span class=n>fit</span><span class=p>();</span>
  <span class=k>return</span> <span class=n>c</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// Calcula b tal que a*b = 1 modulo MOD
</span><span class=c1>// https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
</span><span class=c1></span><span class=n>ll</span> <span class=nf>modinv</span><span class=p>(</span><span class=n>ll</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> 
  <span class=n>ll</span> <span class=n>r0</span> <span class=o>=</span> <span class=n>a</span><span class=p>,</span> <span class=n>r1</span> <span class=o>=</span> <span class=n>MOD</span><span class=p>;</span>
  <span class=n>ll</span> <span class=n>s0</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>s1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=k>while</span><span class=p>(</span><span class=n>r1</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ll</span> <span class=n>q</span> <span class=o>=</span> <span class=n>r0</span><span class=o>/</span><span class=n>r1</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>r</span> <span class=o>=</span> <span class=n>r0</span> <span class=o>-</span> <span class=n>q</span><span class=o>*</span><span class=n>r1</span><span class=p>;</span> <span class=n>r0</span> <span class=o>=</span> <span class=n>r1</span><span class=p>;</span> <span class=n>r1</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
    <span class=n>ll</span> <span class=n>s</span> <span class=o>=</span> <span class=n>s0</span> <span class=o>-</span> <span class=n>q</span><span class=o>*</span><span class=n>s1</span><span class=p>;</span> <span class=n>s0</span> <span class=o>=</span> <span class=n>s1</span><span class=p>;</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=p>(</span><span class=n>s0</span><span class=o>+</span><span class=n>MOD</span><span class=p>)</span><span class=o>%</span><span class=n>MOD</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// Modulo usando el algoritmo de Euclides para polinomios
</span><span class=c1></span><span class=n>poly</span> <span class=k>operator</span><span class=o>%</span><span class=p>(</span><span class=k>const</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=p>)</span> <span class=k>return</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// Si el grado es menor, el resto es a
</span><span class=c1></span>
  <span class=n>poly</span> <span class=n>r</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>

  <span class=n>ll</span> <span class=n>b_lead</span> <span class=o>=</span> <span class=n>b</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=p>),</span> <span class=n>inv_b_lead</span> <span class=o>=</span> <span class=n>modinv</span><span class=p>(</span><span class=n>b_lead</span><span class=p>);</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=n>k</span> <span class=o>&gt;=</span> <span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>--</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ll</span> <span class=n>scale_factor</span> <span class=o>=</span> <span class=p>(</span><span class=n>r</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>*</span><span class=n>inv_b_lead</span><span class=p>)</span><span class=o>%</span><span class=n>MOD</span><span class=p>;</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>r</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>]</span> <span class=o>-=</span> <span class=n>scale_factor</span><span class=o>*</span><span class=n>b</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>n</span><span class=o>-</span><span class=n>i</span><span class=p>);</span>
      <span class=n>r</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
      <span class=k>if</span><span class=p>(</span><span class=n>r</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>r</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=n>r</span><span class=p>.</span><span class=n>fit</span><span class=p>();</span>
  <span class=k>return</span> <span class=n>r</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p><strong>Código para obtener la secuencia</strong></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>poly</span> <span class=nf>exponenciacion_rapida</span><span class=p>(</span><span class=n>poly</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>,</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>mod</span><span class=p>,</span> <span class=n>ll</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// ans inicia como el polinomio unidad i.e. ans(x) = 1
</span><span class=c1></span>  <span class=n>poly</span> <span class=n>ans</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=n>ans</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> 
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>bit</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>bit</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>bit</span> <span class=o>&lt;&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>((</span><span class=n>bit</span><span class=o>&amp;</span><span class=n>n</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>ans</span> <span class=o>=</span> <span class=p>(</span><span class=n>p</span><span class=o>*</span><span class=n>ans</span><span class=p>)</span><span class=o>%</span><span class=n>mod</span><span class=p>;</span> <span class=c1>// Si el k-esimo bit está prendido, multiplicar por p^2^k
</span><span class=c1></span>    <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>*</span><span class=n>p</span><span class=o>%</span><span class=n>mod</span><span class=p>;</span> <span class=c1>// Conseguir la siguiente potencia binaria de p
</span><span class=c1></span>  <span class=p>}</span>

  <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>ll</span> <span class=nf>G</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>ll</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>p</span><span class=p>.</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ans</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>*</span><span class=n>p</span><span class=p>.</span><span class=n>access</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
    <span class=n>ans</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>ll</span> <span class=nf>calcular_ak</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=n>ll</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>c</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> 
  <span class=c1>// Necesitamos tantos casos base como el grado de la recurrencia
</span><span class=c1></span>
  <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
  <span class=k>if</span><span class=p>(</span><span class=n>K</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>)</span> <span class=k>return</span> <span class=n>a</span><span class=p>[</span><span class=n>K</span><span class=p>];</span>

  <span class=n>poly</span> <span class=n>p</span><span class=p>(</span><span class=n>N</span><span class=p>);</span> <span class=c1>// Creamos el polinomio característico de la recurrencia
</span><span class=c1></span>
  <span class=n>p</span><span class=p>[</span><span class=n>N</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>N</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=n>p</span><span class=p>[</span><span class=n>N</span><span class=o>-</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>MOD</span><span class=o>-</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>

  <span class=n>poly</span> <span class=n>x</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// El polinomio base x
</span><span class=c1></span>  <span class=k>return</span> <span class=n>G</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>exponenciacion_rapida</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>K</span><span class=p>));</span> <span class=c1>// Calcular G(x^k mod p)
</span><span class=c1></span><span class=p>}</span>
</code></pre></div></details><h2 id=caso-no-homogéneo><strong>Caso no Homogéneo</strong><a href=#caso-no-homogéneo class=anchor aria-hidden=true>#</a></h2><p>Hasta ahora tenemos una gran estructura para lidiar con el caso homogéneo de las recurrencias, pero no sabemos nada respecto a enfrentar recurrencias que no son homogéneas. Veremos dos casos donde es posible reducir estas recurrencias a otras equivalentes que si son homogéneas, que nos permitirá usar todos los métodos ya explicados.</p><h3 id=caso-fk--b-constante>Caso $f(k) = b$ constante<a href=#caso-fk--b-constante class=anchor aria-hidden=true>#</a></h3><p>Estás son las recurrencias lineales no homogéneas más simples posibles. Se ven de la forma:</p><p>$$
a_k = \sum_{i=1}^{n} c_i a_{k-i} + b
$$</p><p>Usando un truco parecido al del método Kitamasa, podemos restar un $0$ conveniente de la forma $0 = -a_{k-1} + \sum_{i=1}^n c_ia_{(k-1)-i} + b$. Para facilitar la notación, diremos que $c_0 = -1$ para poder escribir esta expresión como $0 = \sum_{i=0}^n c_ia_{(k-1)-i} + b$ y lo restaremos:</p><p>$$
\begin{align*}
a_k &= \sum_{i=1}^{n} c_i a_{k-i} + b - \left[\sum_{i=0}^n c_ia_{(k-1)-i} + b\right] \\<br>&= \sum_{i=1}^{n} c_i a_{k-i} - \sum_{i=0}^n c_ia_{(k-1)-i}
\end{align*}
$$</p><p>Con lo que anulamos $b$ y obtenemos una recurrencia lineal homógenea para $a$. Agrupando terminos, y tomando la convención de que $c_{n+1} = 0$, podemos reescribir esta recurrencia como:</p><p>$$
\hat{c}_i = c_i - c_{i-1} \\<br>a_k = \sum_{i=1}^{n+1} \hat{c}_i a_{k-i}
$$</p><p>Notar que mediante este proceso, creamos una recurrencia homogénea de grado $n+1$ a partir de una no homogénea de grado $n$, por lo que necesitaremos calcular un caso base adicional para resolver esta recurrencia. Podemos calcular a partir de los casos base originales y utilizando la recurrencia original.</p><details><summary>Código</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>
<span class=k>const</span> <span class=n>ll</span> <span class=n>MOD</span> <span class=o>=</span> <span class=mf>1e9</span><span class=o>+</span><span class=mi>7</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>convert</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=n>ll</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>n</span><span class=p>);</span>

  <span class=c1>// Agregamos un caso base adicional
</span><span class=c1></span>  <span class=n>a</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>a</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>+=</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>a</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=n>i</span><span class=p>];</span>
    <span class=n>a</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// Computamos los nuevos coeficientes c_i
</span><span class=c1></span>  <span class=n>c</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-=</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>
    <span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>MOD</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>MOD</span><span class=p>;</span>

  <span class=o>++</span><span class=n>n</span><span class=p>;</span>
  <span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></details><h3 id=caso-fk--pk-polinomio>Caso $f(k) = p(k)$ polinomio<a href=#caso-fk--pk-polinomio class=anchor aria-hidden=true>#</a></h3><p>Podemos generalizar la técnica anterior para polinomios arbitrarios de la forma $p(k) = \sum_{j=0}^m p_j k^j$. En este caso queremos resolver la recurrencia:</p><p>$$
a_k = \sum_{i=1}^{n} c_i a_{k-i} + p(k)
$$</p><p>Vamos a aplicar iterativamente el truco de restar un $0$ conveniente. Usaremos el hecho de que $q(x) = p(x) - p(x-1)$ es un polinomio de grado $m-1$. Utilizaremos la notación $[x^j]p(x)$ para referirnos al coeficiente que acompaña a $x^j$ en el polinomio $p(x)$, y vemos que:</p><p>$$
\begin{matrix}
[x^m]p(x-1) = [x^m]p(x) \Rightarrow [x^m]q(x) = 0 \\[1.5em]
[x^{m-1}]q(x) = [x^{m-1}](p(x) - p(x-1)) \\[1.5em]
= m[x^m]p(x) + [x^{m-1}]p(x) - [x^{m-1}]p(x) = m[x^m]p(x) \neq 0
\end{matrix}
$$</p><p>Entonces, cuando restamos nuestro $0$ conveniente $0 = \sum_{i=0}^n c_ia_{(k-1)-i} + p(k)$, tenemos que:</p><p>$$
\begin{align*}
a_k &= \sum_{i=1}^{n} c_i a_{k-i} + p(k) - \left[\sum_{i=0}^n c_ia_{(k-1)-i} + p(k-1)\right] \\<br>&= \sum_{i=1}^{n} c_i a_{k-i} - \sum_{i=0}^n c_ia_{(k-1)-i} + \left[p(k) - p(k-1)\right] \\<br>&= \sum_{i=1}^{n+1} (c_i-c_{i-1}) a_{k-i} + q(k)
\end{align*}
$$</p><p>Ojo que aquí también estamos usando la convención de que $c_0 = -1$ y $c_{n+1} = 0$. Con este procedimiento, obtenemos una recurrencia lineal no homogénea de grado $n+1$ *con un polinomio $q$ de grado $m-1$*. Es decir que podemos reducir el grado del polinomio en $1$ aumentando el grado de la recurrencia en $1$. Si repetimos este proceso en total $m+1$ veces, obtendremos una recurrencia lineal de grado $n+m+1$ donde el polinomio se anula **por completo**, osea, homogénea. Al finalizar, obtendremos coeficientes $\hat{c}_i$ tal que:</p><p>$$
a_k = \sum_{i=1}^{n+m+1} \hat{c}_i a_{k-i}
$$</p><p>Tomando la convención de que $c_i = 0$ para $i &lt; 0$, podemos escribir una formula explícita para los $\hat{c}_i$:</p><p>$$
\hat{c}_i = \sum_{j=0}^{m+1} (-1)^j \binom{m+1}{j}c_j
$$</p><p>De nuevo, es importante recalcar que para poder resolver esta recurrencia con los métodos que conocemos para recurrencias lineales homogéneas, necesitaremos $m+1$ valores adicionales de la secuencia como base, que podemos obtener utilizando la recurrencia original.</p><details><summary>Código</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>
<span class=k>const</span> <span class=n>ll</span> <span class=n>MOD</span> <span class=o>=</span> <span class=mf>1e9</span><span class=o>+</span><span class=mi>7</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>convert</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ll</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=n>poly</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>assert</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=n>n</span><span class=p>);</span>

  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>n</span><span class=p>;</span>
  <span class=c1>// Debemos agregar m+1 casos base
</span><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>+</span><span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>a</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>eval</span><span class=p>(</span><span class=n>k</span><span class=p>));</span>

    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>];</span>
      <span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>%=</span> <span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c1>// Computamos los nuevos coeficientes c_i
</span><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>+</span><span class=n>m</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>c</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    
    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-=</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>
      <span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>MOD</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>%</span><span class=n>MOD</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=n>n</span> <span class=o>+=</span> <span class=n>m</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
  <span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></details><p class=edit-page><a href=https://github.com/progcompuch/apunte/blob/main/content/docs/extras/recurrencias_lineales.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 09/12/2022 a las 00:56:41 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a class=ml-auto href=/docs/extras/treaps/><div class="card my-1"><div class="card-body py-2">Treaps &rarr;</div></div></a></div></main></div></div></main><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.95e1e463215c36b92eed561d2047bd705784633ba53d9459f103fad71ac9237a03e92e1413824339f4dcfe6e260239c0e4237a48be33d73a1e686e025142d2ba.js integrity="sha512-leHkYyFcNrku7VYdIEe9cFeEYzulPZRZ8QP61xrJI3oD6S4UE4JDOfTc/m4mAjnA5CN6SL4z1zoeaG4CUULSug==" crossorigin=anonymous defer></script><script src=/index.min.4842d09dc7f066902873731a5a97076ea606633dcee608e067d3644daea6d31fe09e9d74caf1262f242d3e0427513335d7d4e4f15d57ba2a4cda20644c2bcb7d.js integrity="sha512-SELQncfwZpAoc3MaWpcHbqYGYz3O5gjgZ9NkTa6m0x/gnp10yvEmLyQtPgQnUTM119Tk8V1XuipM2iBkTCvLfQ==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>
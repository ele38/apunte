<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.c9e56e89b640498932b48f88666fb7dafea2240ca0093d87b8cb2c324b7aa2613f76be82154ceadb06ad2f89c479e382f13e99e177b0ed1817eb59625b34f389.css integrity="sha512-yeVuibZASYkytI+IZm+32v6iJAygCT2HuMssMkt6omE/dr6CFUzq2watL4nEeeOC8T6Z4Xew7RgX61liWzTziQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Caminos más cortos - Programación Competitiva UChile</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/docs/grafos/dijkstra/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Caminos más cortos"><meta name=twitter:description content="Camino más corto en un grafo Con frecuencia encontraremos problemas en los que necesitamos encontrar el camino más corto para llegar desde un nodo hasta otro y dependiendo de las características del grafo tendremos que usar algoritmos distintos. Nota que en un grafo pueden haber múltiplices caminos más cortos (con el mismo peso).
Grafos sin peso Si las aristas del grafo no tienen peso, entonces su distancia es solo la cantidad de aristas por las que se pasa, luego podemos calcular la distancia desde un nodo cualquiera $u$ a todos los demás usando un solo BFS ya que este recorre el grafo expandiéndose."><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Caminos más cortos"><meta property="og:description" content="Camino más corto en un grafo Con frecuencia encontraremos problemas en los que necesitamos encontrar el camino más corto para llegar desde un nodo hasta otro y dependiendo de las características del grafo tendremos que usar algoritmos distintos. Nota que en un grafo pueden haber múltiplices caminos más cortos (con el mismo peso).
Grafos sin peso Si las aristas del grafo no tienen peso, entonces su distancia es solo la cantidad de aristas por las que se pasa, luego podemos calcular la distancia desde un nodo cualquiera $u$ a todos los demás usando un solo BFS ya que este recorre el grafo expandiéndose."><meta property="og:type" content="article"><meta property="og:url" content="/docs/grafos/dijkstra/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2022-03-19T08:48:45+00:00"><meta property="article:modified_time" content="2022-11-27T02:50:55-03:00"><meta property="og:site_name" content="Programación Competitiva UChile"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Docsgrafosdijkstra","item":"\/docsgrafosdijkstra\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/progcompuch/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/docs/prologo/intro>Apunte</a></li><li class=nav-item><a class=nav-link href=/recursos/prologo/intro>Recursos</a></li><li class=nav-item><a class=nav-link href=/cses>CSES</a></li><li class=nav-item><a class=nav-link href=/acerca>Acerca</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Prólogo</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/prologo/intro/>Prólogo</a></li></ul><h3>Intro a la Programación</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/intro/compilacion-editores/>Compilación y Editores de Texto</a></li><li><a class=docs-link href=/docs/intro/sintaxis/>Sintaxis, Variables, Tipos y Ciclos</a></li><li><a class=docs-link href=/docs/intro/funciones/>Funciones en C++</a></li><li><a class=docs-link href=/docs/intro/vectores/>Vectores</a></li><li><a class=docs-link href=/docs/intro/bits/>Operadores Bitwise</a></li></ul><h3>La STL</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/stl/strings/>Chars y Strings</a></li><li><a class=docs-link href=/docs/stl/pair-tuple/>Pair y Tuple</a></li><li><a class=docs-link href=/docs/stl/sort/>Sort</a></li><li><a class=docs-link href=/docs/stl/setmap/>Sets, Maps y Multisets</a></li><li><a class=docs-link href=/docs/stl/stackqueue/>Stack y Queue</a></li><li><a class=docs-link href=/docs/stl/priority_queue/>Priority Queue</a></li></ul><h3>Paradigmas de Resolución</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/paradigmas/busqueda-binaria/>Búsqueda Binaria</a></li><li><a class=docs-link href=/docs/paradigmas/programacion-dinamica/>Programación Dinámica</a></li></ul><h3>Estructuras de Datos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/ds/unionfind/>Union Find</a></li></ul><h3>Grafos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/grafos/introduccion/>Introducción</a></li><li><a class=docs-link href=/docs/grafos/busqueda/>Búsqueda en grafos (BFS y DFS)</a></li><li><a class=docs-link href=/docs/grafos/caminos_eulerianos/>Caminos y Ciclos Eulerianos</a></li><li><a class=docs-link href=/docs/grafos/mst/>Minimum Spanning Tree (MST)</a></li><li><a class="docs-link active" href=/docs/grafos/dijkstra/>Caminos más cortos</a></li></ul><h3>Anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/anexos/template/>Template</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><ul><li><a href=#camino-más-corto-en-un-grafo>Camino más corto en un grafo</a></li><li><a href=#grafos-sin-peso>Grafos sin peso</a></li><li><a href=#grafos-con-pesos-positivos>Grafos con pesos positivos</a></li><li><a href=#grafos-con-ciclos-negativos>Grafos con ciclos negativos</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Caminos más cortos</h1><p class=lead></p><h3 id=camino-más-corto-en-un-grafo>Camino más corto en un grafo<a href=#camino-más-corto-en-un-grafo class=anchor aria-hidden=true>#</a></h3><p>Con frecuencia encontraremos problemas en los que necesitamos encontrar el camino más corto para llegar desde un nodo hasta otro y dependiendo de las características del grafo tendremos que usar algoritmos distintos. Nota que en un grafo
pueden haber múltiplices caminos más cortos (con el mismo peso).</p><h3 id=grafos-sin-peso>Grafos sin peso<a href=#grafos-sin-peso class=anchor aria-hidden=true>#</a></h3><p>Si las aristas del grafo no tienen peso, entonces su distancia es solo la cantidad de aristas por las que se pasa, luego podemos calcular la distancia desde un nodo cualquiera $u$ a todos los demás usando un solo <a href=https://uchile.progcomp.cl/docs/grafos/busqueda/#bfs>BFS</a> ya que este recorre el grafo expandiéndose. Es decir, primero recorre el nodo con distancia cero (el inicial), luego los de distancia uno, luego los de dos, etcétera.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// n es la cantidad de nodos y s la fuente
</span><span class=c1></span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=n>s</span><span class=p>;</span>
<span class=c1>// gr es la lista de adyacencia del grafo
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>gr</span><span class=p>;</span>

<span class=c1>// Iniciamos un vector que tiene la distancia pero si no lo hemos calculado guarda un -1
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>distancia</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>

<span class=c1>// Iniciamos la cola con la source
</span><span class=c1></span><span class=n>queue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>bfs</span><span class=p>;</span>
<span class=n>bfs</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
<span class=n>distancia</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=c1>// Mientras la cola no esté vacía, tenemos nodos que revisar
</span><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>bfs</span><span class=p>.</span><span class=n>empty</span><span class=p>()){</span>
	<span class=c1>// Sacamos el nodo que está en la cola
</span><span class=c1></span>	<span class=kt>int</span> <span class=n>nodo</span> <span class=o>=</span> <span class=n>bfs</span><span class=p>.</span><span class=n>front</span><span class=p>();</span>
	<span class=n>bfs</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
	
	<span class=c1>// Revisamos sus vecinos
</span><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>vecino</span><span class=p>:</span><span class=n>gr</span><span class=p>[</span><span class=n>nodo</span><span class=p>]){</span>
		<span class=c1>// Si no lo hemos visitado, lo visitamos agregándolo a la cola
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>distancia</span><span class=p>[</span><span class=n>vecino</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>){</span>
      <span class=c1>// Y calculamos su distancia como la distancia de la fuente más uno
</span><span class=c1></span>			<span class=n>bfs</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>vecino</span><span class=p>);</span>
			<span class=n>distancia</span><span class=p>[</span><span class=n>vecino</span><span class=p>]</span> <span class=o>=</span> <span class=n>distancia</span><span class=p>[</span><span class=n>nodo</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=grafos-con-pesos-positivos>Grafos con pesos positivos<a href=#grafos-con-pesos-positivos class=anchor aria-hidden=true>#</a></h3><p>Si las aristas tienen peso, pueden haber caminos que tengan más aristas pero que la suma de sus pesos sea menor.
Para esto usamos el algoritmo de Dijkstra, muy similar al BFS pero en vez de usar una cola normal, usamos un <a href=https://uchile.progcomp.cl/docs/stl/priority_queue/><code>priority_queue</code></a> que nos de los nodos más cercanos primero y al asignar la distancia revisamos si es menor a la que tenemos actualmente:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Definimos los pares así al inicio para facilidad de su uso en la priority_queue
</span><span class=c1></span><span class=k>typedef</span> <span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ii</span><span class=p>;</span>

<span class=p>...</span>

<span class=c1>// gr es la lista de adyacencia del grafo que ahora tiene pares con la distancia
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>gr</span><span class=p>;</span>

<span class=c1>// Iniciamos el vector de la misma forma
</span><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>distancia</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>

<span class=c1>// Iniciamos la pq con pares que guardaran (distancia,nodo)
</span><span class=c1>// y cambiamos su configuración para que nos de los más pequeños primero
</span><span class=c1></span><span class=n>priority_queue</span><span class=o>&lt;</span> <span class=n>ii</span><span class=p>,</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span><span class=p>,</span><span class=n>greater</span><span class=o>&lt;</span><span class=n>ii</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>pq</span><span class=p>;</span>

<span class=c1>// Metemos la fuente a la cola y asignamos su distancia
</span><span class=c1></span><span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>ii</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=n>s</span><span class=p>));</span>
<span class=n>distancia</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=c1>// Mientras la cola no esté vacía, tenemos nodos que revisar
</span><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=n>empty</span><span class=p>()){</span>

	<span class=c1>// Sacamos el nodo que esté a menor distancia ahora mismo
</span><span class=c1></span>	<span class=kt>int</span> <span class=n>nodo</span> <span class=o>=</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>().</span><span class=n>first</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>nodo_d</span> <span class=o>=</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>().</span><span class=n>second</span><span class=p>();</span>
	<span class=n>bfs</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>

  <span class=c1>// Si su distancia es mayor que la distancia que tenemos guardada
</span><span class=c1></span>  <span class=c1>// significa que esta distancia ya se actualizó y no nos sirve
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>nodo_d</span> <span class=o>&gt;</span> <span class=n>distancia</span><span class=p>[</span><span class=n>nodo</span><span class=p>])</span> <span class=k>continue</span><span class=p>;</span>
	
	<span class=c1>// Revisamos sus vecinos
</span><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=n>ii</span> <span class=nl>arista</span><span class=p>:</span><span class=n>gr</span><span class=p>[</span><span class=n>nodo</span><span class=p>]){</span>
    <span class=kt>int</span> <span class=n>vecino</span> <span class=o>=</span> <span class=n>arista</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>vecino_d</span> <span class=o>=</span> <span class=n>arista</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
		<span class=c1>// Si no lo hemos visitado o su distancia es mayor que la podemos conseguir ahora lo cambiamos
</span><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>distancia</span><span class=p>[</span><span class=n>vecino</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>distancia</span><span class=p>[</span><span class=n>vecino</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nodo_d</span> <span class=o>+</span> <span class=n>vecino_d</span><span class=p>){</span>
      <span class=n>distancia</span><span class=p>[</span><span class=n>vecino</span><span class=p>]</span> <span class=o>=</span> <span class=n>nodo_d</span> <span class=o>+</span> <span class=n>vecino_d</span><span class=p>;</span>
      <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>ii</span><span class=p>(</span><span class=n>vecino</span><span class=p>,</span><span class=n>nodo_d</span> <span class=o>+</span> <span class=n>vecino_d</span><span class=p>));</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=grafos-con-ciclos-negativos>Grafos con ciclos negativos<a href=#grafos-con-ciclos-negativos class=anchor aria-hidden=true>#</a></h3><p><a href=https://cp-algorithms.com/graph/bellman_ford.html>Bellman-Ford</a></p><p class=edit-page><a href=https://github.com/progcompuch/apunte/blob/main/content/docs/grafos/dijkstra.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 27/11/2022 a las 02:50:55 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/grafos/mst/><div class="card my-1"><div class="card-body py-2">&larr; Minimum Spanning Tree (MST)</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.95e1e463215c36b92eed561d2047bd705784633ba53d9459f103fad71ac9237a03e92e1413824339f4dcfe6e260239c0e4237a48be33d73a1e686e025142d2ba.js integrity="sha512-leHkYyFcNrku7VYdIEe9cFeEYzulPZRZ8QP61xrJI3oD6S4UE4JDOfTc/m4mAjnA5CN6SL4z1zoeaG4CUULSug==" crossorigin=anonymous defer></script><script src=/index.min.ec8fed08a2984723d9b5f08955476c479e4c977668a16b9ff61d8e2c7bda1f0a7efd37c7c6a23a9f1697ba63f053b49ebfa88ac743d09428916f3e91ce92bd3a.js integrity="sha512-7I/tCKKYRyPZtfCJVUdsR55Ml3ZooWuf9h2OLHvaHwp+/TfHxqI6nxaXumPwU7Sev6iKx0PQlCiRbz6RzpK9Og==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>
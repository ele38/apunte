<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.03312bd7248a76fe3a982d6f25da03b46f2ec82ccaae0f89fa02c6a5f29d137fa8c20ca65a27f27f356f3d178c8d52f6b76dee9fbca257e9e81a151adba7dd67.css integrity="sha512-AzEr1ySKdv46mC1vJdoDtG8uyCzKrg+J+gLGpfKdE3+owgymWifyfzVvPReMjVL2t23un7yiV+noGhUa26fdZw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Caminos y Ciclos Eulerianos - Programación Competitiva UChile</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/docs/grafos/caminos_eulerianos/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Caminos y Ciclos Eulerianos"><meta name=twitter:description content="Introducción Un camino euleriano es un camino que ocupa todas las aristas de un grafo sin repetirlas. Además, este camino será un ciclo euleriano si también es un ciclo (empieza y termina en el mismo nodo). Primero asumiremos un grafo no dirigido y al final hablaremos de grafos dirigidos. Permitiremos que sea un multigrafo (con aristas repetidas entre un par de nodos).
A continuación un camino euleriano. Nota que los nodos de inicio y fin están marcados, y las aristas están enumeradas:"><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Caminos y Ciclos Eulerianos"><meta property="og:description" content="Introducción Un camino euleriano es un camino que ocupa todas las aristas de un grafo sin repetirlas. Además, este camino será un ciclo euleriano si también es un ciclo (empieza y termina en el mismo nodo). Primero asumiremos un grafo no dirigido y al final hablaremos de grafos dirigidos. Permitiremos que sea un multigrafo (con aristas repetidas entre un par de nodos).
A continuación un camino euleriano. Nota que los nodos de inicio y fin están marcados, y las aristas están enumeradas:"><meta property="og:type" content="article"><meta property="og:url" content="/docs/grafos/caminos_eulerianos/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2022-03-19T08:48:45+00:00"><meta property="article:modified_time" content="2022-11-27T17:29:06-03:00"><meta property="og:site_name" content="Programación Competitiva UChile"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Docsgrafoscaminos Eulerianos","item":"\/docsgrafoscaminos_eulerianos\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/progcompuch/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/docs/prologo/intro>Apunte</a></li><li class=nav-item><a class=nav-link href=/recursos/prologo/intro>Recursos</a></li><li class=nav-item><a class=nav-link href=/cses>CSES</a></li><li class=nav-item><a class=nav-link href=/acerca>Acerca</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><main class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Prólogo</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/prologo/intro/>Prólogo</a></li></ul><h3>Intro a la Programación</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/intro/compilacion-editores/>Compilación y Editores de Texto</a></li><li><a class=docs-link href=/docs/intro/sintaxis/>Sintaxis, Variables, Tipos y Ciclos</a></li><li><a class=docs-link href=/docs/intro/funciones/>Funciones en C++</a></li><li><a class=docs-link href=/docs/intro/vectores/>Vectores</a></li><li><a class=docs-link href=/docs/intro/bits/>Operadores Bitwise</a></li></ul><h3>La STL</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/stl/strings/>Chars y Strings</a></li><li><a class=docs-link href=/docs/stl/pair-tuple/>Pair y Tuple</a></li><li><a class=docs-link href=/docs/stl/sort/>Sort</a></li><li><a class=docs-link href=/docs/stl/setmap/>Sets, Maps y Multisets</a></li><li><a class=docs-link href=/docs/stl/stackqueue/>Stack y Queue</a></li><li><a class=docs-link href=/docs/stl/priority_queue/>Priority Queue</a></li></ul><h3>Paradigmas de Resolución</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/paradigmas/busqueda-binaria/>Búsqueda Binaria</a></li><li><a class=docs-link href=/docs/paradigmas/programacion-dinamica/>Programación Dinámica</a></li></ul><h3>Estructuras de Datos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/ds/unionfind/>Union Find</a></li></ul><h3>Grafos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/grafos/introduccion/>Introducción</a></li><li><a class=docs-link href=/docs/grafos/busqueda/>Búsqueda en grafos (BFS y DFS)</a></li><li><a class="docs-link active" href=/docs/grafos/caminos_eulerianos/>Caminos y Ciclos Eulerianos</a></li><li><a class=docs-link href=/docs/grafos/mst/>Minimum Spanning Tree (MST)</a></li><li><a class=docs-link href=/docs/grafos/dijkstra/>Caminos más cortos</a></li></ul><h3>Extras</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/extras/recurrencias_lineales/>Recurrencias Lineales</a></li></ul><h3>Anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/anexos/template/>Template</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><a href=#introducción>Introducción</a></li><li><a href=#condiciones>Condiciones</a><ul><li><a href=#conectividad>Conectividad</a></li><li><a href=#grados-de-los-vértices>Grados de los vértices</a></li></ul></li><li><a href=#implementación>Implementación</a></li><li><a href=#grafos-dirigidos>Grafos dirigidos</a></li><li><a href=#problemas>Problemas</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Caminos y Ciclos Eulerianos</h1><p class=lead></p><h2 id=introducción>Introducción<a href=#introducción class=anchor aria-hidden=true>#</a></h2><p>Un camino euleriano es un camino que ocupa todas las <strong>aristas</strong> de un grafo sin repetirlas. Además, este camino será un <strong>ciclo</strong> euleriano
si también es un ciclo (empieza y termina en el mismo nodo). Primero asumiremos un grafo no dirigido y al final hablaremos de grafos
dirigidos. Permitiremos que sea un multigrafo (con aristas repetidas entre un par de nodos).</p><p>A continuación un camino euleriano. Nota que los nodos de inicio y fin están marcados, y las aristas están enumeradas:</p><center><img class=invertible src=../camino_euleriano.png width=300></center>
Y un ciclo euleriano se ve así:
<center><img class=invertible src=../ciclo_euleriano.png width=300></center><p>Ten cuidado de no confundir un camino euleriano (cada arista se visita una vez) con uno hamiltoniano (cada nodo se visita una vez).</p><h2 id=condiciones>Condiciones<a href=#condiciones class=anchor aria-hidden=true>#</a></h2><h3 id=conectividad>Conectividad<a href=#conectividad class=anchor aria-hidden=true>#</a></h3><p>Para que puedan existir caminos o ciclos eulerianos, obviamente necesitamos que el grafo sea <em>suficientemente conexo</em>. Esto significa
que todas las aristas estén en la misma componente conexa (pero podrían haber nodos aislados fuera de ésta).</p><h3 id=grados-de-los-vértices>Grados de los vértices<a href=#grados-de-los-vértices class=anchor aria-hidden=true>#</a></h3><h4 id=ciclo-euleriano>Ciclo euleriano<a href=#ciclo-euleriano class=anchor aria-hidden=true>#</a></h4><p>Para que exista un ciclo euleriano, todos los vértices deben tener grado par (donde el grado de un vértice es la cantidad de vecinos o aristas que salen de él).
Es simple notar que esta condición es necesaria, puesto que cada vez que en el camino entramos a un nodo $u$, también tenemos que salir de él. Es decir:</p><p>\begin{align*}
(\text{veces que entramos a $u$})+(\text{veces que salimos de $u$}) &= \text{grado}(u) \newline
2 \cdot (\text{veces que entramos a $u$}) &= \text{grado}(u) \newline
&\implies \text{grado}(u) \text{ es par}.
\end{align*}</p><p>Si un vértice tuviera grado impar, podríamos entrar pero no salir de él. O salir de él pero no volver a entrar, si empezamos en él.</p><h4 id=camino-euleriano-no-cíclico>Camino euleriano no cíclico<a href=#camino-euleriano-no-cíclico class=anchor aria-hidden=true>#</a></h4><p>Al ser un camino no cíclico, existen dos nodos en los que no se cumple la propiedad de salir y entrar la misma cantidad de veces: el inicial y el final.</p><p>En el nodo inicial del camino salimos al inicio pero no compensamos esa salida con una entrada, y en el final entramos pero no compensamos con una salida puesto
que el camino termina ahí y no es necesario salir. Así, para que exista un camino euleriano no cíclico tienen que haber exactamente dos vértices
de grado impar.</p><p>Veamos que estas condiciones no son solo necesarias si no que también suficientes. Es decir, demostraremos que si se cumplen las condiciones de las paridades, entonces existe un camino o ciclo euleriano:</p><details><summary>Demostración semi formal</summary><p><strong>Teorema</strong>: Un grafo $G=(V,E)$ suficientemente conexo con todos los grados de vértices pares tiene un ciclo euleriano.</p><p><strong>Demostración</strong>: Por inducción fuerte.</p><p>Si $|V| = 2$, simplemente tomamos repetidamente las aristas entre los dos nodos (recuerda que permitimos aristas múltiples). Como hay una cantidad par de aristas, terminaremos en el mismo nodo que empezamos.</p><p>En el caso $|V| > 2$, escogemos un nodo $u$ inicial. Recorremos el grafo escogiendo aristas hasta volver a $u$. Sabemos que volveremos ya que no podemos quedarnos atrapados en otro nodo, porque como los grados
son pares si podemos entrar a un nodo también podemos salir.</p><p>Este procedimiento genera un ciclo, no necesariamente euleriano ya que podría no ocupar todas las aristas del grafo. Sea $G' = (V, E')$ el grafo resultante al remover todas las aristas del ciclo encontrado, ya que
cada vértice fue visitado una cantidad par de veces, todos los vértices de $G'$ siguen teniendo grado par. Así, para cada componente de $G'$, que tienen tamaño menor a $|V|$, por la hipótesis inductiva podemos encontrar
un ciclo euleriano en todas ellas.</p><p>Como el grafo era originalmente conexo, todos estos ciclos eulerianos comparten algún nodo con nuestro ciclo original, así que los podemos unir formando un solo ciclo euleriano que usa todas las aristas.</p><p><strong>Teorema</strong>: Un grafo $G=(V,E)$ suficientemente conexo con dos vértices de grado impar y todos los demás de grado par tiene un camino euleriano.</p><p><strong>Demostración</strong>: Sean $u$ y $v$ los dos vértices de grado impar. Agregaremos una arista ficticia $(u,v)$ y tendremos $G' = (V, E \cup \{u ,v\})$. Ahora todos los vértices en $G'$ tienen grado par
y por el teorema anterior, hay un ciclo euleriano.</p><p>Encontramos este ciclo y removemos la arista ficticia, convirtiéndose en un camino euleriano de $G$.</p></details><h2 id=implementación>Implementación<a href=#implementación class=anchor aria-hidden=true>#</a></h2><p>Primero veremos cómo encontrar un <strong>ciclo</strong> euleriano. La idea consiste en hacer un DFS pero en vez de marcar los nodos como visitados (e impedir que se repitan) marcaremos las aristas como visitadas. Así, el DFS
recorrerá todas las aristas del grafo. Para lograr obtener los nodos visitados en el orden válido, cada vez que se retorne de una llamada recursiva agregaremos el nodo actual a la respuesta, consiguiendo unir los ciclos.</p><details><summary>Código ciclo euleriano</summary><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;bits/stdc++.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=n>vector</span> <span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>edges</span><span class=p>;</span>
<span class=n>vector</span> <span class=o>&lt;</span><span class=n>vector</span> <span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>adj</span><span class=p>;</span>
<span class=n>vector</span> <span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ans</span><span class=p>;</span> <span class=c1>// El ciclo euleriano quedará acá
</span><span class=c1></span><span class=n>vector</span> <span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>used</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>dfs</span><span class=p>(</span><span class=kt>int</span> <span class=n>u</span><span class=p>){</span>
	<span class=k>while</span><span class=p>(</span><span class=n>adj</span><span class=p>[</span><span class=n>u</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
		<span class=kt>int</span> <span class=n>e</span> <span class=o>=</span> <span class=n>adj</span><span class=p>[</span><span class=n>u</span><span class=p>].</span><span class=n>back</span><span class=p>();</span>
		<span class=n>adj</span><span class=p>[</span><span class=n>u</span><span class=p>].</span><span class=n>pop_back</span><span class=p>();</span> <span class=c1>// Borramos la arista para que no se vuelva a usar
</span><span class=c1></span>		<span class=k>if</span><span class=p>(</span><span class=n>used</span><span class=p>[</span><span class=n>e</span><span class=p>])</span> <span class=k>continue</span><span class=p>;</span> <span class=c1>// Si ya fue usada (desde el otro lado, la inversa) la ignoramos
</span><span class=c1></span>		<span class=n>used</span><span class=p>[</span><span class=n>e</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
 		<span class=c1>// El XOR es para encontrar el que es distinto. Los dos que son iguales se cancelan entre si.
</span><span class=c1></span>		<span class=c1>// Es lo mismo que (edges[i].first == u ? edges[i].second : edges[i].first)
</span><span class=c1></span>		<span class=n>dfs</span><span class=p>(</span><span class=n>edges</span><span class=p>[</span><span class=n>e</span><span class=p>].</span><span class=n>first</span> <span class=o>^</span> <span class=n>edges</span><span class=p>[</span><span class=n>e</span><span class=p>].</span><span class=n>second</span> <span class=o>^</span> <span class=n>u</span><span class=p>);</span>
		<span class=n>ans</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>u</span><span class=p>);</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
	<span class=cm>/*
</span><span class=cm>		Leer el input. A diferencia de una lista de adyacencia común,
</span><span class=cm>		en la lista de adyacencia de un nodo no guardaremos los índices
</span><span class=cm>		de los otros nodos, si no que guardaremos los índices de las aristas,
</span><span class=cm>		y las aristas están en &#39;edges&#39;
</span><span class=cm>		Input de ejemplo:
</span><span class=cm>		n m
</span><span class=cm>		u1 v1
</span><span class=cm>		u2 v2
</span><span class=cm>		...
</span><span class=cm>		um vm
</span><span class=cm>	*/</span>
	<span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>m</span><span class=p>;</span>
	<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>n</span> <span class=o>&gt;&gt;</span> <span class=n>m</span><span class=p>;</span>
	<span class=n>adj</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
	<span class=n>used</span><span class=p>.</span><span class=n>assign</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
	<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
		<span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>u</span> <span class=o>&gt;&gt;</span> <span class=n>v</span><span class=p>;</span>
		<span class=n>u</span><span class=o>--</span><span class=p>;</span> <span class=n>v</span><span class=o>--</span><span class=p>;</span> <span class=c1>// borrar si ya vienen indexados de cero
</span><span class=c1></span>		<span class=n>edges</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>u</span><span class=p>,</span><span class=n>v</span><span class=p>);</span>
		<span class=n>adj</span><span class=p>[</span><span class=n>u</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
		<span class=n>adj</span><span class=p>[</span><span class=n>v</span><span class=p>].</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// quitar si el grafo es dirigido
</span><span class=c1></span>	<span class=p>}</span>
	<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
		<span class=k>if</span><span class=p>(</span><span class=n>adj</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>){</span>
			<span class=c1>// Hay un nodo de grado impar. No existe ciclo euleriano
</span><span class=c1></span>			<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;IMPOSSIBLE</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
			<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=n>ans</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
	<span class=n>dfs</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
	<span class=k>if</span><span class=p>(</span><span class=n>ans</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>!=</span> <span class=n>m</span><span class=o>+</span><span class=mi>1</span><span class=p>){</span>
		<span class=c1>// El ciclo encontrado no usa todas las aristas. El grafo no tiene todas las aristas en la misma
</span><span class=c1></span>		<span class=c1>// componente conexa.
</span><span class=c1></span>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;IMPOSSIBLE</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>ans</span><span class=p>){</span>
		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=o>+</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></details><p>Si quisiéramos encontrar un <strong>camino</strong> euleriano, debemos encontrar los dos vértices $u$ y $v$ de grado impar, agregar la arista ficticia $(u,v)$, encontrar un ciclo euleriano (ahora tienen grado par)
y luego quitar la arista ficticia (encontrar la rotación del ciclo tal que $u$ queda al inicio y $v$ al final).</p><h2 id=grafos-dirigidos>Grafos dirigidos<a href=#grafos-dirigidos class=anchor aria-hidden=true>#</a></h2><p>En un grafo dirigido hay que ser un poco más cuidadosos con las condiciones. Ahora:</p><ul><li>Si el grado de entrada es igual al grado de salida en todos los nodos, y además las aristas forman una componente fuertemente conexa, hay ciclo euleriano.</li><li>Si el grado de entrada es igual al de salida en todos los nodos, y existe un nodo tal que $(\text{grado salida})-(\text{grado entrada}) = 1$, y otro nodo tal que $(\text{grado entrada})-(\text{grado salida}) = 1$, y además agregando ambas aristas entre estos dos nodos se forma una componente fuertemente conexa,
entonces hay un camino euleriano no cíclico que empieza en el primero de estos y termina en el segundo.</li></ul><p>También en el código anterior no tenemos que agregar la arista $(v, u)$ si nos entregan una arista $(u, v)$ (marcado con un comentario).</p><h2 id=problemas>Problemas<a href=#problemas class=anchor aria-hidden=true>#</a></h2><p><a href=https://cses.fi/problemset/task/1691>CSES 1691 - Mail Delivery</a></p><p><a href=https://cses.fi/problemset/task/1693>CSES 1693 - Teleporters Path</a></p><p><a href=https://codeforces.com/contest/508/problem/D>CODEFORCES 508D - Tanya and Password</a></p><p class=edit-page><a href=https://github.com/progcompuch/apunte/blob/main/content/docs/grafos/caminos_eulerianos.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 27/11/2022 a las 17:29:06 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/grafos/busqueda/><div class="card my-1"><div class="card-body py-2">&larr; Búsqueda en grafos (BFS y DFS)</div></div></a><a class=ml-auto href=/docs/grafos/mst/><div class="card my-1"><div class="card-body py-2">Minimum Spanning Tree (MST) &rarr;</div></div></a></div></main></div></div></main><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.95e1e463215c36b92eed561d2047bd705784633ba53d9459f103fad71ac9237a03e92e1413824339f4dcfe6e260239c0e4237a48be33d73a1e686e025142d2ba.js integrity="sha512-leHkYyFcNrku7VYdIEe9cFeEYzulPZRZ8QP61xrJI3oD6S4UE4JDOfTc/m4mAjnA5CN6SL4z1zoeaG4CUULSug==" crossorigin=anonymous defer></script><script src=/index.min.15b8cbc689ff24214afce594db189730b977f1f663bce6c33bfcb08ef89de97b9f80e47f3319541ec426df99b9b33baf4e54bef9033dd0b1a6e2c761f196520f.js integrity="sha512-FbjLxon/JCFK/OWU2xiXMLl38fZjvObDO/ywjvid6XufgOR/MxlUHsQm35m5szuvTlS++QM90LGm4sdh8ZZSDw==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Librería estándar de C++ on</title><link>/apunte/libreria_estandar/</link><description>Recent content in Librería estándar de C++ on</description><generator>Hugo -- gohugo.io</generator><atom:link href="/apunte/libreria_estandar/index.xml" rel="self" type="application/rss+xml"/><item><title>Char y string</title><link>/apunte/libreria_estandar/char_string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/libreria_estandar/char_string/</guid><description>Chars # Los caracteres en C++ en realidad son guardados como números dentro del computador, estos números son interpretados como un carácter al ocupar el programa pero son números por debajo lo cual nos permite hacer algunos usos interesantes de estos.
La correspondencia entre el número y el carácter que representa está dada por el código ASCII, no es necesario que sepan de memoria la correspondencia entre números y símbolos, solo saber como funciona es suficiente.</description></item><item><title>Pair y tuple</title><link>/apunte/libreria_estandar/pair_tuple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/libreria_estandar/pair_tuple/</guid><description>Hasta ahora, solo hemos podido guardar 1 solo valor en los vectores, queues, stacks, etc. Esto puede no llegar a ser un mayor problema, ya que siempre se pueden crear múltiples vectores, pero, y si queremos ordenar un vector, pero aún así conocer la posición inicial que tenian los valores?, necesitamos una forma de mantener el valor y el índice juntos, y es aquí donde los pair entran al juego.</description></item><item><title>Sort</title><link>/apunte/libreria_estandar/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/libreria_estandar/sort/</guid><description>Ordenar # Con frecuencia en problemas de programación nos será de utilidad tener los elementos ordenados y si has visto antes el problema de ordenar un arreglo sabrás que se puede resolver con una complejidad de $O(nlogn)$, siendo $n$ el tamaño del arreglo, pero esto no es simple de programar. Por suerte, C++ tiene implementada la función sort que nos permite ordenar distintas estructuras con esta complejidad.
Para usar sort solo necesitamos entregar dos punteros a donde parte y termina el espacio, para un arreglo es:</description></item><item><title>Set, map y multiset</title><link>/apunte/libreria_estandar/set_map_multiset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/libreria_estandar/set_map_multiset/</guid><description>Set # Quizás te suene una estructura llamada &amp;ldquo;árbol de búsqueda binaria&amp;rdquo;, sin entrar en detalles de su implementación esta estructura guarda un conjunto de elementos de forma ordenada y permite insertar, buscar y eliminar elementos con una complejidad de $O( \log(n) \cdot k )$ donde $n$ es el tamaño del conjunto y $k$ es la complejidad de comparar dos elementos. Ahora, la parte complicada de esto es la implementación pero C++ tiene la estructura set que está implementada como uno de estos árboles lo cual nos da todos los beneficios en términos de complejidad sin tener que implementar todo desde cero, pero usar esta estructura es bastante distinto a usar un vector así que es necesario aprender a usarla.</description></item><item><title>Stack y queue</title><link>/apunte/libreria_estandar/stack_queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/libreria_estandar/stack_queue/</guid><description>En esta sección vamos a ver un par de estructuras que nos permiten organizar nuestros datos de una forma muy específica, las cuales pueden no parecer muy útiles en un principio pero aparecen frecuentemente en los distintos algoritmos que se verán más adelante así que es importante entenderlas, saber como funcionan y como usarlas.
Stack # El stack es una estructura LIFO (Last In, First Out), lo que significa que cuando sacamos un elemento de esta vamos a obtener el último elemento que pusimos en él.</description></item><item><title>Priority queue</title><link>/apunte/libreria_estandar/priority_queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apunte/libreria_estandar/priority_queue/</guid><description>Priority Queue # La priority_queue es un contenedor de elementos que permite insertar y obtener el máximo elemento con complejidad $O( \log(n) \cdot k )$ donde $k$ es la complejidad de comparar dos elementos. Puede que esto suene como una estructura limitada que cumple una función muy específica, pero esto es algo que se ve repetido bastante en algoritmos y problemas.
Esta estructura internamente implementa un heap, no es necesaria entenderla a profundidad para usarla.</description></item></channel></rss>